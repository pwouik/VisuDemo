#version 460 core
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D imgOutput;
uniform mat4 inv_proj;
uniform mat4 inv_view;
uniform uvec2 screen_size;
uniform vec3 camera;
uniform float time;

	
#define fold45(p)(p.y>p.x)?p.yx:p
float sdf( vec3 p ){
    float scale = 2.1, off0 = .8, off1 = .3, off2 = .83;
    vec3 off =vec3(2.,.2,.1);
    float s=1.0;
    for(int i = 0;++i<20;) {
      p.xy = abs(p.xy);
      p.xy = fold45(p.xy);
      p.y -= off0;
      p.y = -abs(p.y);
      p.y += off0;
      p.x += off1;
      p.xz = fold45(p.xz);
      p.x -= off2;
      p.xz = fold45(p.xz);
      p.x += off1;
      p -= off;
      p *= scale;
      p += off;
      s *= scale;
    }
    return length(p)/s;
  }
const uint max_iter = 128;

void main() {
    if(gl_GlobalInvocationID.x>=screen_size.x || gl_GlobalInvocationID.y>=screen_size.y)
        return;
    uvec3 grid_size = gl_WorkGroupSize * gl_NumWorkGroups;
    vec3 dir = normalize( mat3(inv_view) * vec3(inv_proj * vec4(float(gl_GlobalInvocationID.x)/grid_size.x*2.0-1.0, float(gl_GlobalInvocationID.y)/grid_size.y*2.0-1.0,1.0,1.0)));
    vec3 pos = camera / 100;
    uint steps = 0;
    for( int i=0; i<max_iter; i++ )
    {
        float dist = sdf(pos);
        pos += dir*dist;
        steps+=1;
        if(dist<=0.01){
            break;
        }
    }
    vec4 color = vec4(0.0,0.0,0.0,1.0);
    if(steps<max_iter){
        float c = float(steps)/max_iter;
        color = vec4(c,c,c,1.0);
    }
    imageStore(imgOutput, ivec2(gl_GlobalInvocationID.xy), color);
}