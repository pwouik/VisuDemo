#version 460 core
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D imgOutput;
uniform mat4 inv_proj;
uniform mat4 inv_view;
uniform uvec2 screen_size;
uniform vec3 camera;
uniform vec3 light_pos;
uniform float time;

	
#define fold45(p)(p.y>p.x)?p.yx:p
float de2( vec3 p ){
    float scale = 2.1, off0 = .8, off1 = .3, off2 = .83;
    vec3 off =vec3(2.,.2,.1);
    float s=1.0;
    for(int i = 0;++i<20;) {
      p.xy = abs(p.xy);
      p.xy = fold45(p.xy);
      p.y -= off0;
      p.y = -abs(p.y);
      p.y += off0;
      p.x += off1;
      p.xz = fold45(p.xz);
      p.x -= off2;
      p.xz = fold45(p.xz);
      p.x += off1;
      p -= off;
      p *= scale;
      p += off;
      s *= scale;
    }
    return length(p)/s-0.0001;
}
const uint max_iter = 256;
const float EPSILON = 1e-4;
const float PI = 3.14159265358979;

#define CSize vec3(1., 1.7, 1.)

float de1( vec3 p )
{
	p = p.xzy;
	float scale = 1.1;
	for( int i=0; i < 8;i++ )
	{
		p = 2.0*clamp(p, -CSize, CSize) - p;
		//float r2 = dot(p,p);
        float r2 = dot(p,p+sin(p.z*.3)); //Alternate fractal
		float k = max((2.)/(r2), .5);
		p     *= k;
		scale *= k;
	}
	float l = length(p.xy);
	float rxy = l - 1.0;
	float n = l * p.z;
	rxy = max(rxy, (n) / 8.);
	return (rxy) / abs(scale);
}
float de(vec3 p){
    p.z-=16.; float s=3.; float e=0.;
    p.y=abs(p.y)-1.8;
    p=clamp(p,-3.,3.)*2.-p;
    s*=e=6./clamp(dot(p,p),1.5,50.);
    p=abs(p)*e-vec3(0,1.8,0);
    p.xz =.8-abs(p.xz-2.);
    p.y =1.7-abs(p.y-2.);
    s*=e=12./clamp(dot(p,p),1.0,50.);
    p=abs(p)*e-vec2(.2,1).xyx;
    p.y =1.5-abs(p.y-2.);
    s*=e=16./clamp(dot(p,p),.1,9.);
    p=abs(p)*e-vec2(.3,-.7).xyx;
    return min(
            length(p.xz)-.5,
            length(vec2(length(p.xz)-12.,p.y))-3.
            )/s;
  }
vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        de(vec3(p.x + EPSILON, p.y, p.z)) - de(vec3(p.x - EPSILON, p.y, p.z)),
        de(vec3(p.x, p.y + EPSILON, p.z)) - de(vec3(p.x, p.y - EPSILON, p.z)),
        de(vec3(p.x, p.y, p.z  + EPSILON)) - de(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

vec4 phong(vec3 pos,float k_a, float k_d, float k_s, float alpha) {
    vec3 normal = estimateNormal(pos);
    vec3 light_dir = normalize(light_pos-pos);
    vec3 reflect_dir = reflect(-light_dir,normal);
    vec3 pos_dir = normalize(camera - pos);
    float diffuse = max(dot(normal,light_dir),0.0) * k_d;
    float specular = pow(max(dot(pos_dir,reflect_dir),0.0),alpha) * k_s * (sign(dot(light_dir,normal))*0.5+0.5);
    return vec4(vec3(0.0,0.0,1.0) * k_a +
                    vec3(1.0,0.8,0.0) * diffuse * k_d + 
                    vec3(1.0,1.0,1.0) * specular * k_s,1.0);
}

void main() {
    if(gl_GlobalInvocationID.x>=screen_size.x || gl_GlobalInvocationID.y>=screen_size.y)
        return;
    uvec3 grid_size = gl_WorkGroupSize * gl_NumWorkGroups;
    vec3 dir = normalize( mat3(inv_view) * vec3(inv_proj * vec4(float(gl_GlobalInvocationID.x)/grid_size.x*2.0-1.0, float(gl_GlobalInvocationID.y)/grid_size.y*2.0-1.0,1.0,1.0)));
    vec3 pos = camera;
    uint steps = 0;
    float dist = 0;
    for( int i=0; i<max_iter; i++ )
    {
        float d = de(pos);
        pos += dir*d;
        dist+=d;
        steps+=1;
        if(d<dist*1e-5){
            break;
        }
    }
    vec4 color = vec4(0.0,0.0,0.0,1.0);
    if(steps<max_iter){
        color = phong(pos,0.1,0.7,1.0,10.0);
    }
    imageStore(imgOutput, ivec2(gl_GlobalInvocationID.xy), color);
}