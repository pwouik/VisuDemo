#version 460 core
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D imgOutput;
uniform mat4 inv_proj;
uniform mat4 inv_view;
uniform uvec2 screen_size;
uniform vec3 camera;
uniform float time;

	
#define fold45(p)(p.y>p.x)?p.yx:p
float sdf( vec3 p ){
    float scale = 2.1, off0 = .8, off1 = .3, off2 = .83;
    vec3 off =vec3(2.,.2,.1);
    float s=1.0;
    for(int i = 0;++i<20;) {
      p.xy = abs(p.xy);
      p.xy = fold45(p.xy);
      p.y -= off0;
      p.y = -abs(p.y);
      p.y += off0;
      p.x += off1;
      p.xz = fold45(p.xz);
      p.x -= off2;
      p.xz = fold45(p.xz);
      p.x += off1;
      p -= off;
      p *= scale;
      p += off;
      s *= scale;
    }
    return length(p)/s;
}
const uint max_iter = 256;
const float EPSILON = 1e-4;
const float PI = 3.14159265358979;

float de(vec3 p0){
    vec4 p = vec4(p0/10., 1.);
    p=abs(p);
    if(p.x < p.z)p.xz = p.zx;
    if(p.z < p.y)p.zy = p.yz;
    if(p.y < p.x)p.yx = p.xy;
    for(int i = 0; i < 6; i++){
      if(p.x < p.z)p.xz = p.zx;
      if(p.z < p.y)p.zy = p.yz;
      if(p.y < p.x)p.yx = p.xy;
      p = abs(p);
      p*=(2./clamp(dot(p.xyz,p.xyz),0.1,1.));
      p.xyz-=vec3(0.9,1.9,0.9);
    }
    float m = 1.5;
    p.xyz-=clamp(p.xyz,-m,m);
    return (length(p.xyz)/p.w)*10.;
  }

vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        de(vec3(p.x + EPSILON, p.y, p.z)) - de(vec3(p.x - EPSILON, p.y, p.z)),
        de(vec3(p.x, p.y + EPSILON, p.z)) - de(vec3(p.x, p.y - EPSILON, p.z)),
        de(vec3(p.x, p.y, p.z  + EPSILON)) - de(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

vec4 phong(vec3 pos,float k_a, float k_d, float k_s, float alpha) {
    vec3 normal = estimateNormal(pos);
    vec3 light_dir = normalize(vec3(0.2,0.1,0.0));
    vec3 reflect_dir = reflect(-light_dir,normal);
    vec3 pos_dir = normalize(camera - pos);
    return vec4(vec3(1.0,1.0,1.0) * k_a +
                    vec3(1.0,1.0,0.0) * max(dot(normal,pos_dir),0.0) * k_d + 
                    vec3(1.0,1.0,1.0) * pow(max(dot(pos_dir,reflect_dir),0.0),alpha) * k_s * sign(dot(light_dir,normal))*0.5+0.5,1.0);
}

void main() {
    if(gl_GlobalInvocationID.x>=screen_size.x || gl_GlobalInvocationID.y>=screen_size.y)
        return;
    uvec3 grid_size = gl_WorkGroupSize * gl_NumWorkGroups;
    vec3 dir = normalize( mat3(inv_view) * vec3(inv_proj * vec4(float(gl_GlobalInvocationID.x)/grid_size.x*2.0-1.0, float(gl_GlobalInvocationID.y)/grid_size.y*2.0-1.0,1.0,1.0)));
    vec3 pos = camera / 100;
    uint steps = 0;
    for( int i=0; i<max_iter; i++ )
    {
        float dist = de(pos);
        pos += dir*dist;
        steps+=1;
        if(dist<=EPSILON){
            break;
        }
    }
    vec4 color = vec4(0.0,0.0,0.0,1.0);
    if(steps<max_iter){
        color = phong(pos,.01,.2,1.0,10.0);
    }
    imageStore(imgOutput, ivec2(gl_GlobalInvocationID.xy), color);
}