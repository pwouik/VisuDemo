#version 460 core

// Defines the size of a thread group for efficient execution on the GPU
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// Uniforms for accessing data from the main shader
layout(rgba32f, binding = 0) uniform image2D imgOutput; // Output image to write results
uniform mat4 inv_proj;                                  // Inverted projection matrix
uniform mat4 inv_view;                                  // Inverted view matrix
uniform uvec2 screen_size;                              // Screen size (width and height)
uniform vec3 camera;                                    // Camera position
uniform vec3 light_pos;                                 // Light position
uniform vec3 param1;                                    // Additional parameter for some fractals (e.g., shift)
uniform float k_a;
uniform vec3 ambient;
uniform float k_d;
uniform vec3 diffuse;
uniform float k_s;
uniform float alpha;
uniform vec3 specular;
uniform float occlusion;
uniform float time;                                     // Time variable (unused in this shader)
uniform vec3 fractal_position;                          // Position of the fractal
uniform vec3 fractal_rotation;                          // Rotation of the fractal


#define fold45(p)(p.y>p.x)?p.yx:p

// Function to estimate the distance for the Mandelbrot fractal variation
float de2(vec3 p){
    float scale = 2.1, off0 = .8, off1 = .3, off2 = .83;
    vec3 off =vec3(2., .2, .1); // Offset vector
    float s=1.0;
    for (int i = 0;++i<20;) {
        // Perform a series of folding and scaling operations on the x, y, and z components
        p.xy = abs(p.xy);
        p.xy = fold45(p.xy);
        p.y -= off0;
        p.y = -abs(p.y);
        p.y += off0;
        p.x += off1;
        p.xz = fold45(p.xz);
        p.x -= off2;
        p.xz = fold45(p.xz);
        p.x += off1;
        p -= off;
        p *= scale;
        p += off;
        s *= scale;
    }
    return length(p)/s-0.0001;  // Return the normalized distance estimate
}

const uint max_iter = 64;          // Maximum number of iterations for ray casting
const float EPSILON = 1e-3;         // Epsilon value for early termination
const float PI = 3.14159265358979;  // Pi constant

#define CSize vec3(1., 1.7, 1.)

// Function to estimate the distance for the Mandelbox fractal
float de1(vec3 p)
{
    p = p.xzy; // Swizzle the x, y, and z components
    float scale = 1.1;
    for (int i=0; i < 8;i++)
    {
        // Perform operations on the x, y, and z components to achieve the fractal pattern
        p = 2.0*clamp(p, -CSize, CSize) - p;
        // Alternate calculation using sine for variation
        //float r2 = dot(p,p);
        float r2 = dot(p, p+sin(p.z*.3));
        float k = max((2.)/(r2), .5);
        p     *= k;
        scale *= k;
    }
    float l = length(p.xy);     // Calculate the length in the xy plane
    float rxy = l - 1.0;        // Distance from (1, 1, 1) in the xy plane
    float n = l * p.z;          // Dot product of p.xy and z
    rxy = max(rxy, (n) / 8.);   // Adjust distance based on z component
    return (rxy) / abs(scale);  // Return the normalized distance estimate
}

// Function to estimate the distance for the Sponge fractal
float de(vec3 p) {
    // The Sponge fractal parameters
    float scale = 1.88f;
    float angle1 = 1.52f;
    float angle2 = 4.91f;
    vec3 shift = param1;                        // Additional parameter for shifting   
    vec2 a1 = vec2(sin(angle1), cos(angle1));
    vec2 a2 = vec2(sin(angle2), cos(angle2));
    mat2 rmZ = mat2(a1.y, a1.x, -a1.x, a1.y);   // Rotation matrix around the Z-axis
    mat2 rmX = mat2(a2.y, a2.x, -a2.x, a2.y);   // Rotation matrix around the X-axis
    float s = 1.0;
    
    for (int i = 0; i <12; ++i) {
        // Apply a series of transformations (rotations, reflections, scaling, and shifting)
        p.xyz = abs(p.xyz);
        p.xy *= rmZ;
        p.xy += min(p.x - p.y, 0.0) * vec2(-1., 1.);
        p.xz += min(p.x - p.z, 0.0) * vec2(-1., 1.);
        p.yz += min(p.y - p.z, 0.0) * vec2(-1., 1.);
        p.yz *= rmX;
        p *= scale;
        s *= scale;
        p.xyz += shift;
    }

    vec3 d = abs(p) - vec3(6.0f);                                           // Calculate the distance from the surface
    return (min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0))) / s;   // Return the normalized distance
}

// Function to estimate the normal vector at a given point
vec3 estimateNormal(vec3 p, float e) {
    return normalize(vec3(
    de(vec3(p.x + e, p.y, p.z)) - de(vec3(p.x - e, p.y, p.z)),
    de(vec3(p.x, p.y + e, p.z)) - de(vec3(p.x, p.y - e, p.z)),
    de(vec3(p.x, p.y, p.z  + e)) - de(vec3(p.x, p.y, p.z - e))
    ));
}

mat3 rotationMatrix(vec3 angles) {
    float cx = cos(angles.x), sx = sin(angles.x);
    float cy = cos(angles.y), sy = sin(angles.y);
    float cz = cos(angles.z), sz = sin(angles.z);

    // Rotation matrices for each axis
    mat3 rx = mat3(1.0, 0.0, 0.0,
    0.0, cx, -sx,
    0.0, sx, cx);

    mat3 ry = mat3(cy, 0.0, sy,
    0.0, 1.0, 0.0,
    -sy, 0.0, cy);

    mat3 rz = mat3(cz, -sz, 0.0,
    sz, cz, 0.0,
    0.0, 0.0, 1.0);

    return rz * ry * rx; // Combine rotations (order: z * y * x)
}

// Phong lighting model for calculating color
vec4 phong(vec3 pos, float ao, float e) {
    mat3 rot = rotationMatrix(fractal_rotation);
    vec3 local_pos = rot * (pos - fractal_position); // Transform into fractal space
    
    vec3 normal = estimateNormal(local_pos, e);           // Estimate the normal vector at the point
    if (dot(normal, pos - camera) > 0.0) {
        normal = -normal; // Flip the normal if it faces away from the camera
    }
    
    vec3 light_dir = normalize(light_pos - pos);      // Calculate the direction to the light source
    vec3 reflect_dir = reflect(-light_dir, normal); // Calculate the reflection direction
    vec3 pos_dir = normalize(camera - pos);         // Calculate the direction to the camera
    // Calculate diffuse and specular components
    float coeff_diffuse = max(dot(normal, light_dir), 0.0) * k_d;
    float coeff_specular = pow(max(dot(pos_dir, reflect_dir), 0.0), exp(alpha)) * k_s * (sign(dot(light_dir, normal))*0.5+0.5);
    // Combine ambient, diffuse, and specular components to get the final color
    return vec4(ambient * k_a * ( 1.0-ao) + ao *(
                 diffuse * coeff_diffuse *k_d +
                 specular * coeff_specular * k_s), 1.0);
}

void main() {
    // Check if the current thread is within the bounds of the screen
    if (gl_GlobalInvocationID.x>=screen_size.x || gl_GlobalInvocationID.y>=screen_size.y)
        return;
    
    // Calculate the ray direction in world space
    uvec3 grid_size = gl_WorkGroupSize * gl_NumWorkGroups;
    vec3 dir = normalize(mat3(inv_view) * vec3(inv_proj * vec4(float(gl_GlobalInvocationID.x)/grid_size.x*2.0-1.0, float(gl_GlobalInvocationID.y)/grid_size.y*2.0-1.0, 1.0, 1.0)));

    // Initialize ray marching variables
    vec3 pos = camera;  // Starting position of the ray
    uint steps = 0;
    float dist = 0;

    mat3 rot = rotationMatrix(fractal_rotation);
    
    // Ray marching loop
    for (int i=0; i<max_iter; i++)
    {
        vec3 local_pos = rot * (pos - fractal_position); // Transform into fractal space
        float d = de(local_pos);  // Calculate the distance to the surface
        
        pos += dir*d;       // Step along the ray
        dist += d;
        steps += 1;
        if (d<dist*EPSILON){ // Early termination condition
            break;
        }
    }
    vec4 color =  phong(pos, exp(-float(steps)*exp(-occlusion)),dist*EPSILON);
    imageStore(imgOutput, ivec2(gl_GlobalInvocationID.xy), color);
}