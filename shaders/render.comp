#version 460 core
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D imgOutput;
uniform mat4 inv_proj;
uniform mat4 inv_view;
uniform uvec2 screen_size;
uniform vec3 camera;
uniform vec3 light_pos;
uniform vec3 param1;
uniform float k_a;
uniform vec3 ambient;
uniform float k_d;
uniform vec3 diffuse;
uniform float k_s;
uniform float alpha;
uniform vec3 specular;
uniform float occlusion;
uniform float time;

	
#define fold45(p)(p.y>p.x)?p.yx:p
float de2( vec3 p ){
    float scale = 2.1, off0 = .8, off1 = .3, off2 = .83;
    vec3 off =vec3(2.,.2,.1);
    float s=1.0;
    for(int i = 0;++i<20;) {
      p.xy = abs(p.xy);
      p.xy = fold45(p.xy);
      p.y -= off0;
      p.y = -abs(p.y);
      p.y += off0;
      p.x += off1;
      p.xz = fold45(p.xz);
      p.x -= off2;
      p.xz = fold45(p.xz);
      p.x += off1;
      p -= off;
      p *= scale;
      p += off;
      s *= scale;
    }
    return length(p)/s-0.0001;
}
const uint max_iter = 64;
const float EPSILON = 1e-3;
const float PI = 3.14159265358979;

#define CSize vec3(1., 1.7, 1.)

float de1( vec3 p )
{
	p = p.xzy;
	float scale = 1.1;
	for( int i=0; i < 8;i++ )
	{
		p = 2.0*clamp(p, -CSize, CSize) - p;
		//float r2 = dot(p,p);
        float r2 = dot(p,p+sin(p.z*.3)); //Alternate fractal
		float k = max((2.)/(r2), .5);
		p     *= k;
		scale *= k;
	}
	float l = length(p.xy);
	float rxy = l - 1.0;
	float n = l * p.z;
	rxy = max(rxy, (n) / 8.);
	return (rxy) / abs(scale);
}
float de( vec3 p ) {
  //The Sponge
  float scale = 1.88f;
  float angle1 = 1.52f;
  float angle2 = 4.91f;
  vec3 shift = param1;
  vec2 a1 = vec2(sin(angle1), cos(angle1));
  vec2 a2 = vec2(sin(angle2), cos(angle2));
  mat2 rmZ = mat2(a1.y, a1.x, -a1.x, a1.y);
  mat2 rmX = mat2(a2.y, a2.x, -a2.x, a2.y);
  float s = 1.0;
  for (int i = 0; i <12; ++i) {
    p.xyz = abs(p.xyz);
    p.xy *= rmZ;
    p.xy += min( p.x - p.y, 0.0 ) * vec2( -1., 1. );
    p.xz += min( p.x - p.z, 0.0 ) * vec2( -1., 1. );
    p.yz += min( p.y - p.z, 0.0 ) * vec2( -1., 1. );
    p.yz *= rmX;
    p *= scale;
    s *= scale;
    p.xyz += shift;
  }
  vec3 d = abs( p ) - vec3( 6.0f );
  return ( min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) ) ) / s;
}
vec3 estimateNormal(vec3 p,float e) {
    return normalize(vec3(
        de(vec3(p.x + e, p.y, p.z)) - de(vec3(p.x - e, p.y, p.z)),
        de(vec3(p.x, p.y + e, p.z)) - de(vec3(p.x, p.y - e, p.z)),
        de(vec3(p.x, p.y, p.z  + e)) - de(vec3(p.x, p.y, p.z - e))
    ));
}

vec4 phong(vec3 pos,float e) {
    vec3 normal = estimateNormal(pos,e);
    vec3 light_dir = normalize(light_pos-pos);
    vec3 reflect_dir = reflect(-light_dir,normal);
    vec3 pos_dir = normalize(camera - pos);
    float coeff_diffuse = max(dot(normal,light_dir),0.0) * k_d;
    float coeff_specular = pow(max(dot(pos_dir,reflect_dir),0.0),exp(alpha)) * k_s * (sign(dot(light_dir,normal))*0.5+0.5);
    return vec4(ambient * k_a +
                    diffuse * coeff_diffuse * k_d + 
                    specular * coeff_specular * k_s,1.0);
}

void main() {
    if(gl_GlobalInvocationID.x>=screen_size.x || gl_GlobalInvocationID.y>=screen_size.y)
        return;
    uvec3 grid_size = gl_WorkGroupSize * gl_NumWorkGroups;
    vec3 dir = normalize( mat3(inv_view) * vec3(inv_proj * vec4(float(gl_GlobalInvocationID.x)/grid_size.x*2.0-1.0, float(gl_GlobalInvocationID.y)/grid_size.y*2.0-1.0,1.0,1.0)));
    vec3 pos = camera;
    uint steps = 0;
    float dist = 0;
    for( int i=0; i<max_iter; i++ )
    {
        float d = de(pos);
        pos += dir*d;
        dist+=d;
        steps+=1;
        if(d<dist*EPSILON){
            break;
        }
    }
    float ao = exp(-float(steps)/exp(occlusion));
    vec4 color =  phong(pos,dist*EPSILON);
    imageStore(imgOutput, ivec2(gl_GlobalInvocationID.xy), color);
}