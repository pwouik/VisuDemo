#version 460 core
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D target;
layout(r32i, binding = 1) uniform iimage2D depth;
layout(r32i, binding = 4) uniform iimage2D jumpdist; //texture that store jump distances
uniform mat4 inv_view;
uniform mat4 inv_proj;
uniform uvec2 screen_size;

#define PI 3.14159265358
mat2 inv_proj_small;

uniform float JD_FR_MIN;
uniform float JD_FR_MAX;
uniform float JD_TO_MIN;
uniform float JD_TO_MAX;


//float d, dnx, dny, dpx, dpy; //distance 
vec3 wco, wconx, wcony, wcopx, wcopy; // world coordinate
vec3 ssnormal; //normals computed from screen space

uniform vec3 camera;
uniform float k_a;
uniform vec3 col_ambient;
uniform float k_d;
uniform vec3 col_diffuse;
uniform float k_s;
uniform float alpha;
uniform vec3 col_specular;

//could be removed. Also in app.cpp there may be dubious glm::inverse uses.
float sampleDepth(ivec2 pos){
    vec2 prod  = inv_proj_small * vec2(float(imageLoad(depth,pos).r)/(1<<31),1);
    return prod.x / prod.y * inv_proj[0].x * screen_size.x/2;
}

float sampleJumpDist(ivec2 pos){
    float jd = float(imageLoad(jumpdist, pos).r)/(1<<31);
    return (jd-JD_FR_MIN)/(JD_FR_MAX-JD_FR_MIN) * (JD_TO_MAX-JD_TO_MIN) + JD_TO_MIN;
}

vec3 getWorldPosition(ivec2 pos) {
    float z = float(imageLoad(depth, pos).r) / (1 << 31);

    // Convert from screen space to normalized device coordinates (NDC)
    vec2 ndc = vec2(pos) / screen_size * 2.0 - 1.0;

    // Form the clip space position
    vec4 clipSpacePos = vec4(ndc, z, 1.0);

    // Unproject to world space
    vec4 worldSpacePos = inv_view*inv_proj * clipSpacePos;

    //perspective divide
    worldSpacePos /= worldSpacePos.w;

    return worldSpacePos.xyz; // Return the 3D world position
}

void computeNormals(){
    wco = getWorldPosition(ivec2(gl_GlobalInvocationID.xy));
    wconx = getWorldPosition(ivec2(gl_GlobalInvocationID.xy)-ivec2(1,0));
    wcopx = getWorldPosition(ivec2(gl_GlobalInvocationID.xy)+ivec2(1,0));
    wcony = getWorldPosition(ivec2(gl_GlobalInvocationID.xy)-ivec2(0,1));
    wcopy = getWorldPosition(ivec2(gl_GlobalInvocationID.xy)+ivec2(0,1));

    vec3 up = normalize(wcopy-wco);
    vec3 down = normalize(wcony-wco);
    vec3 right = normalize(wcopx-wco);
    vec3 left = normalize(wconx-wco);

    //braindead normal approximation. TODO maybe add a distance check to detect case where pixel above is missing
    //for some reason there's a minus sign here. Can't expalin why sry
    //Actually there's a bunch of minus sign here and so. The result looks like phong shading so whatever everything probably cancels out
    ssnormal = -(cross(up,right) + cross(right, down) + cross(down, left), + cross(left, up))/4;
}

vec3 phong(vec3 color, float min_light,float shadow,float ao) {
    vec3 light = vec3(0,10,0);


    vec3 light_dir = normalize(light - wco);      // Calculate the direction to the light source
    vec3 reflect_dir = reflect(-light_dir, ssnormal); // Calculate the reflection direction
    vec3 pos_dir = normalize(camera - wco);         // Calculate the direction to the camera
    // Calculate diffuse and specular components
    float coeff_diffuse = dot(ssnormal, light_dir);
    float coeff_specular = pow(max(dot(pos_dir, reflect_dir), 0.0), exp(alpha)) * k_s;
    // Combine ambient, diffuse, and specular components to get the final color
    return vec3(color *(max(coeff_diffuse *k_d * shadow,min_light) * ao) +
                 col_specular * coeff_specular * k_s * shadow);
}

void main() {
    // Check if the current thread is within the bounds of the screen
    if (gl_GlobalInvocationID.x>=screen_size.x || gl_GlobalInvocationID.y>=screen_size.y)
        return;

    inv_proj_small = mat2(inv_proj[2].zw,inv_proj[3].zw);

    float d = sampleDepth(ivec2(gl_GlobalInvocationID.xy));
    if(d<-99999){//early break for background
        imageStore(target, ivec2(gl_GlobalInvocationID.xy), vec4(0,0,0,1));
        return;
    }

    
    float dj =  sampleJumpDist(ivec2(gl_GlobalInvocationID.xy));

    computeNormals();

    //Phong
    //imageStore(target, ivec2(gl_GlobalInvocationID.xy), vec4(phong().xyz,1)); 

    //prise en compte de la jump distance pour faire un gradient sur la base color ?
    vec3 col_cloud = phong(vec3(1.0,1.0,0),0.1,1.0,1.0);
    imageStore(target, ivec2(gl_GlobalInvocationID.xy), vec4(col_cloud.xyz,1)); 


    //debugging display normals
    //imageStore(target, ivec2(gl_GlobalInvocationID.xy), vec4(abs(ssnormal.zyx),1)); 
    
    //debuging coordinate space matching ?
    //when moving mouse the result changes proving a mistake somewhere in computation
    // if(camera.x < wco.x)
    //     imageStore(target, ivec2(gl_GlobalInvocationID.xy), vec4(1,0,0,1));
    // else
    //     imageStore(target, ivec2(gl_GlobalInvocationID.xy), vec4(0,0,1,1)); 

}