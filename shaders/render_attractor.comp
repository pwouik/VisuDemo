#version 460 core
layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D imgOutput;
layout(std430, binding = 3) buffer PointBuffer {          // SSBO binding point 3
    vec4 points[];
};
layout(std140, binding = 1) uniform Matrices { // the list of mat4 attractors
    mat4 matrixArray[10];
};
uniform int curr_mat_count; //number of matrices in array
uniform int randInt_seed;

uniform mat4 inv_proj;
uniform mat4 inv_view;
uniform uvec2 screen_size;
uniform vec3 camera;
uniform vec3 light_pos;
uniform float time;


//tmp hardcode matrices here for now
mat4 matri0 = transpose(mat4(   0.5f, 0.0f,  0.0f, 0.0f,
                                0.0f, 0.5f,  0.0f, 0.36f,
                                0.0f, 0.0f,  0.0f, 0.0f,
                                0.0f, 0.0f,  0.0f, 1.0f));
mat4 matri1 = transpose(mat4(   0.5f, 0.0f,  0.0f, -0.5f,
                                0.0f, 0.5f,  0.0f, -0.5f,
                                0.0f, 0.0f,  0.0f, 0.0f,
                                0.0f, 0.0f,  0.0f, 1.0f));
mat4 matri2 = transpose(mat4(   0.5f, 0.0f,  0.0f, 0.5f,
                                0.0f, 0.5f,  0.0f, -0.5f,
                                0.0f, 0.0f,  0.0f, 0.0f,
                                0.0f, 0.0f,  0.0f, 1.0f));

// mat4 matri0 = mat4( 0.995f, 0.0f,  0.0f, 0.0f,
//                     0.0f, 1.0f,  0.0f, 0.0f,
//                     0.0f, 0.0f,  1.0, 0.0f,
//                     0.0f, 0.0f,  0.0f, 1.0f);

// mat4 matri1 = mat4( 1.0f, 0.0f,  0.0f, 0.0f,
//                     0.0f, 0.995f,  0.0f, 0.0f,
//                     0.0f, 0.0f,  1.0f, 0.0f,
//                     0.0f, 0.0f,  0.0f, 1.0f);

// mat4 matri2 = mat4( 1.0f, 0.0f,  0.0f, 0.0f,
//                     0.0f, 1.0f,  0.0f, 0.0f,
//                     0.0f, 0.0f,  0.995f, 0.0f,
//                     0.0f, 0.0f,  0.0f, 1.0f);


	

const uint max_iter = 256;
const float EPSILON = 1e-4;
const float PI = 3.14159265358979;

#define NBPTS 1000000
//TODO optimisation : lower number of thread to process multiples point per thread ?

void screenWriteCoord(vec4 pt){
    vec4 camera_space = inv_view * pt;

    vec4 projected_point = inv_proj * camera_space;
    if (projected_point.w != 0.0) {
        projected_point.xyz /= projected_point.w; // Perspective divide
    }

    vec2 screen_coord = (projected_point.xy + 1.0) * 0.5; // [-1,1] to [0,1]
    screen_coord *= vec2(screen_size); // Map to screen space (pixels)

    //default color for now
    vec4 color = vec4(1.0, 0.5, 0.5, 1.0); 

    //who needs a clipping plane or a z buffer ? 
    imageStore(imgOutput, ivec2(screen_coord), color);
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if(idx >= NBPTS) return;

    vec4 point = points[idx];
    vec4 pts[3];

    //update point coordinate with attractor (for now choose attractor with % index but later have custom weight)
    if(curr_mat_count > 0) {
        //points[idx] = matrixArray[idx%curr_mat_count] * point;
        
        uint rand = (idx%randInt_seed)%curr_mat_count;
        //uint rand = idx%curr_mat_count;

        //compute all points to display
        pts[0] = matri0 * point;
        pts[1] = matri1 * point;
        pts[2] = matri2 * point;

        //pick only one 
        if(rand == 0) points[idx] = pts[0];
        if(rand == 1) points[idx] = pts[1];
        if(rand == 2) points[idx] = pts[2];
    }
    //optimization : draw multiple from one
    screenWriteCoord(pts[0]);
    screenWriteCoord(pts[1]);
    screenWriteCoord(pts[2]);
}