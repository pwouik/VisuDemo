#version 460 core
layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D imgOutput;
layout(std430, binding = 3) buffer PointBuffer {          // SSBO binding point 3
    vec4 points[];
};
layout(std140, binding = 1) uniform Matrices { // the list of mat4 attractors
    mat4 matrixArray[10];
};
uniform int curr_mat_count; //number of matrices in array

uniform mat4 inv_proj;
uniform mat4 inv_view;
uniform uvec2 screen_size;
uniform vec3 camera;
uniform vec3 light_pos;
uniform float time;


//tmp hardcode matrices here for now
mat4 matri0 = mat4( 0.5f, 0.0f,  0.0f, 0.0f,
                    0.0f, 0.5f,  0.0f, 0.36f,
                    0.0f, 0.0f,  0.0f, 0.0f,
                    0.0f, 0.0f,  0.0f, 1.0f);
mat4 matri1 = mat4( 0.5f, 0.0f,  0.0f, -0.5f,
                    0.0f, 0.5f,  0.0f, -0.5f,
                    0.0f, 0.0f,  0.0f, 0.0f,
                    0.0f, 0.0f,  0.0f, 1.0f);
mat4 matri2 = mat4( 0.5f, 0.0f,  0.0f, 0.5f,
                    0.0f, 0.5f,  0.0f, -0.5f,
                    0.0f, 0.0f,  0.0f, 0.0f,
                    0.0f, 0.0f,  0.0f, 1.0f);

	

const uint max_iter = 256;
const float EPSILON = 1e-4;
const float PI = 3.14159265358979;

#define NBPTS 100000
//TODO optimisation : lower number of thread to process multiples point per thread ?

void screenWriteCoord(vec4 pt){
    vec4 camera_space = inv_view * pt;

    vec4 projected_point = inv_proj * camera_space;
    if (projected_point.w != 0.0) {
        projected_point.xyz /= projected_point.w; // Perspective divide
    }

    vec2 screen_coord = (projected_point.xy + 1.0) * 0.5; // [-1,1] to [0,1]
    screen_coord *= vec2(screen_size); // Map to screen space (pixels)

    //default color for now
    vec4 color = vec4(1.0, 0.5, 0.5, 1.0); 

    //who needs a clipping plane or a z buffer ? 
    imageStore(imgOutput, ivec2(screen_coord), color);
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if(idx >= NBPTS) return;

    vec4 point = points[idx];

    //update point coordinate with attractor (for now choose attractor with % index but later have custom weight)
    if(curr_mat_count > 0) {
        //points[idx] = matrixArray[idx%curr_mat_count] * point;
        uint rand = idx%curr_mat_count;
        if(rand == 0) points[idx] = matri0 * point;
        if(rand == 1) points[idx] = matri1 * point;
        if(rand == 2) points[idx] = matri2 * point;
    }

    screenWriteCoord(point);
}