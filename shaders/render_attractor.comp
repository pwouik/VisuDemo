#version 460 core
layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D imgOutput;
layout(std430, binding = 3) buffer PointBuffer {          // SSBO binding point 3
    vec4 points[];
};
layout(std140, binding = 1) uniform Matrices { // the list of mat4 attractors
    mat4 matrixArray[10];
};
uniform int randInt_seed;
uniform int matrixPerAttractor; //number of matrices in array
uniform int immobileCount; //number of point that won't move

uniform mat4 proj;
uniform mat4 view;
uniform uvec2 screen_size;
uniform vec3 camera;
uniform vec3 light_pos;
uniform float time;


//tmp hardcode matrices here for now
// mat4 matri0 = transpose(mat4(   0.5f, 0.0f,  0.0f, 0.0f,
//                                 0.0f, 0.5f,  0.0f, 0.36f,
//                                 0.0f, 0.0f,  0.0f, 0.0f,
//                                 0.0f, 0.0f,  0.0f, 1.0f));
// mat4 matri1 = transpose(mat4(   0.5f, 0.0f,  0.0f, -0.5f,
//                                 0.0f, 0.5f,  0.0f, -0.5f,
//                                 0.0f, 0.0f,  0.0f, 0.0f,
//                                 0.0f, 0.0f,  0.0f, 1.0f));
// mat4 matri2 = transpose(mat4(   0.5f, 0.0f,  0.0f, 0.5f,
//                                 0.0f, 0.5f,  0.0f, -0.5f,
//                                 0.0f, 0.0f,  0.0f, 0.0f,
//                                 0.0f, 0.0f,  0.0f, 1.0f));

// mat4 matri0 = transpose(mat4(   0.5f, 0.2f,  0.0f, 0.0f,
//                                 0.0f, 0.7f,  0.0f, 0.36f,
//                                 0.0f, 0.0f,  0.0f, -0.2f,
//                                 0.0f, 0.0f,  0.4f, 1.0f));
// mat4 matri1 = transpose(mat4(   0.7f, 0.0f,  0.0f, -0.5f,
//                                 0.0f, 0.5f,  0.0f, -0.5f,
//                                 0.2f, 0.0f,  0.2f, 0.0f,
//                                 0.0f, 0.0f,  0.0f, 1.0f));
// mat4 matri2 = transpose(mat4(   0.5f, 0.0f,  0.0f, 0.5f,
//                                 0.0f, 0.5f,  0.0f, 0.5f,
//                                 0.0f, 0.0f,  0.6f, 0.3f,
//                                 0.0f, 0.0f,  0.0f, 1.0f));

// mat4 matri0 = matrixArray[0];
// mat4 matri1 = matrixArray[1];
// mat4 matri2 = matrixArray[2];


const uint max_iter = 256;
const float EPSILON = 1e-4;
const float PI = 3.14159265358979;

#define NBPTS 20000000
//TODO optimisation : lower number of thread to process multiples point per thread ?

void screenWriteCoord(vec4 pt){
    vec4 camera_space = view * pt;

    vec4 projected_point = proj * camera_space;
    if (projected_point.w != 0.0) {
        projected_point.xyz /= projected_point.w; // Perspective divide
    }
    if(projected_point.z>1.0){return;}

    vec2 screen_coord = (projected_point.xy + 1.0) * 0.5; // [-1,1] to [0,1]
    screen_coord *= vec2(screen_size); // Map to screen space (pixels)

    //default color for now
    vec4 color = vec4(1.0, 0.5, 0.5, 1.0); 

    //who needs a clipping plane or a z buffer ? 
    imageStore(imgOutput, ivec2(screen_coord), color);
}
uint hash(uint x)
{
    x ^= x >> 17;
    x *= 0xed5ad4bbU;
    x ^= x >> 11;
    x *= 0xac4c1b51U;
    x ^= x >> 15;
    x *= 0x31848babU;
    x ^= x >> 14;
    return x;
}
void main() {
    uint idx = gl_GlobalInvocationID.x;
    if(idx >= NBPTS) return;

    vec4 point = points[idx];
    vec4 pts[3];

    //update point coordinate with attractor (for now choose attractor with % index but later have custom weight)
    if(matrixPerAttractor > 0) {        
        //get a pseudo random number. This may requieres fix because of overhead (multiples points getting traped in the same loop) TODO
        uint fake_rand = hash(idx^randInt_seed)%(matrixPerAttractor+immobileCount); 

        //Assuming 3 attroctor funciton per attractor
        //compute all points to display
        for(int i =0; i < matrixPerAttractor; i++){
            pts[i] = matrixArray[i] * point;
        }

        //pick only one 
        if(fake_rand == 0) points[idx] = pts[0];
        if(fake_rand == 1) points[idx] = pts[1];
        if(fake_rand == 2) points[idx] = pts[2];
    }
    //optimization : draw multiple from one
    for(int i =0; i < matrixPerAttractor; i++){
        screenWriteCoord(pts[i]);
    }
}