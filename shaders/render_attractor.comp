#version 460 core
layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
layout(r32i, binding = 1) uniform iimage2D depth;
layout(std140, binding = 1) uniform Matrices { // the list of mat4 attractors
    mat4 matrixArray[10];
};
layout(std430, binding = 3) buffer PointBuffer {          // SSBO points
    vec4 points[];
};
layout(r32f, binding = 4) uniform image2D jumpdist; //texture that store jump distances
uniform int randInt_seed;   //a random value per frame (between 0 and RAND_MAX, WARNING RAND_MAX depends on compiler !)
uniform int matrixPerAttractor; //number of matrices in array

uniform mat4 proj;
uniform mat4 view;
uniform uvec2 screen_size;
uniform vec3 camera;
uniform vec3 light_pos; //not used currently
uniform float time; //not used currently



const uint max_iter = 256;
const float EPSILON = 1e-4;
const float PI = 3.14159265358979;

//magic values
#define NBPTS 5000000
#define MAX_FUNC_PER_ATTRACTOR 10 //magic value synced with matthracttor.hpp
//TODO Changed MAX_FUNC_PER_ATTRACTOR to 3 or 5 to lower useless memory usage


/*
Wether we should use main v1 or v2 is hightly debatable and seems to depends on GPU !
- on CY-PC, main 2 seems better (-30% perf for 4 times more point)
- on my RTX980 main 2 divide perf by 8 for some reasons

*/


void screenWriteCoord(vec4 pt, float dist_jump){
    vec4 camera_space = view * pt;

    vec4 projected_point = proj * camera_space;
    if (projected_point.w != 0.0) {
        projected_point.xyz /= projected_point.w; // Perspective divide
    }
    if(projected_point.z>1.0){return;}

    vec2 screen_coord = (projected_point.xy + 1.0) * 0.5; // [-1,1] to [0,1]
    screen_coord *= vec2(screen_size); // Map to screen space (pixels) 
    int d = int(projected_point.z*(1<<31));
    if(imageLoad(depth, ivec2(screen_coord)).r<d){
        imageStore(depth, ivec2(screen_coord), ivec4(d));
        imageStore(jumpdist, ivec2(screen_coord), vec4(dist_jump));
        //other metadata
    }
}
uint hash(uint x){
    x ^= x >> 17;
    x *= 0xed5ad4bbU;
    x ^= x >> 11;
    x *= 0xac4c1b51U;
    x ^= x >> 15;
    x *= 0x31848babU;
    x ^= x >> 14;
    return x;
}

//MAIN VERSION 1 : draw 1 generation (all reachable point from current pos)
void main() {
    uint idx = gl_GlobalInvocationID.x;
    if(idx >= NBPTS) return;

    vec4 point = points[idx];
    vec4 pts[MAX_FUNC_PER_ATTRACTOR];
    float dist_jump;

    //update point coordinate with attractor
    if(matrixPerAttractor > 0) {        
        //get a unique seed per thread. 
        uint fake_rand = hash(idx^randInt_seed)%(matrixPerAttractor); 

        //compute all points to display. Note that 3<matrixPerAttractor<MAX_FUNC_PER_ATTRACTOR = 10
        for(int i =0; i < matrixPerAttractor; i++){
            pts[i] = matrixArray[i] * point;
        }

        //jump to a random position
        for(int i =0; i < matrixPerAttractor; i++){
            if(fake_rand == i){
                points[idx] = pts[i];
                dist_jump = distance(pts[i], point);
                break; //idk if break really optimized in glsl
            }
        }

    }
    //draw all points
    for(int i =0; i < matrixPerAttractor; i++){
        screenWriteCoord(pts[i],dist_jump);
    }
}

//MAIN BERSION 2 : draw 2 generation (all points reachable point from the first generation)
void main_desac() {
    uint idx = gl_GlobalInvocationID.x;
    if(idx >= NBPTS) return;

    vec4 point = points[idx];
    vec4 pts_gen1[MAX_FUNC_PER_ATTRACTOR];
    vec4 pts_gen2[MAX_FUNC_PER_ATTRACTOR*MAX_FUNC_PER_ATTRACTOR];

    //update point coordinate with attractor
    if(matrixPerAttractor > 0) {        
        //get a unique seed per thread. 
        uint fake_rand = hash(idx^randInt_seed)%(matrixPerAttractor*matrixPerAttractor); 

        //compute all points to display. Note that 3<matrixPerAttractor<MAX_FUNC_PER_ATTRACTOR = 10
        for(int i =0; i < matrixPerAttractor; i++){
            pts_gen1[i] = matrixArray[i] * point;
            for(int k=0; k<matrixPerAttractor; k++){
                pts_gen2[i*matrixPerAttractor+k] = matrixArray[k] * pts_gen1[i];
            }
        }

        //jump to a random position
        for(int i =0; i < matrixPerAttractor*matrixPerAttractor; i++){
            if(fake_rand == i){
                points[idx] = pts_gen2[i];
                break; //idk if break really optimized in glsl
            }
        }

    }
    //draw all reachable points form gen1 & gen2.
    for(int i =0; i < matrixPerAttractor; i++){
        screenWriteCoord(pts_gen1[i],0.5);
    }
    for(int i =0; i < matrixPerAttractor*matrixPerAttractor; i++){
        screenWriteCoord(pts_gen2[i],0.5);
    }
}